### 可见性

## 什么是线程间的可见性？
一个线程对共享变量值的修改，能够及时的被其他线程看到。

## 什么是共享变量？
如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。

## 共享变量可见性实现的原理： 
线程1对共享变量的修改要想被线程2及时看到，必须经过如下2个步骤： 
1、把工作内存1中更新过的共享变量刷新到主内存中 
2、将主内存中最新的共享变量的值更新到工作内存2中

## 导致共享变量在线程间不可见的原因
1、线程交叉执行
2、重排序结合线程交叉执行
3、共享变量更新后的值没有在工作内存与主存间及时更新

## java语言层面支持的可见性实现方式有以下两种： 
1、synchronized 
2、volatile


## synchronized实现可见性以及原子性

# JMM关于synchronized的两条规定： 
1、线程解锁前（退出synchronized代码块之前），必须把共享变量的最新值刷新到主内存中，也就是说线程退出synchronized代码块值后，主内存中保存的共享变量的值已经是最新的了 
2、线程加锁时（进入synchronized代码块之后），将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁） 

# 两者结合：线程解锁前对共享变量的修改在下次加锁时对其他线程可见 

# 根据以上推出线程执行互斥代码的过程： 
1、获得互斥锁（进入synchronized代码块） 
2、清空工作内存 
3、从主内存拷贝变量的最新副本到工作内存 
4、执行代码 
5、将更改后的共享变量的值刷新到主内存 
6、释放互斥锁（退出synchronized代码块）


## volatile实现可见性

# volatile特性： 
1、能够保证volatile变量的可见性 
2、不能保证volatile变量复合操作的原子性

# 如何实现内存可见性？ 
通过加入内存屏障和禁止重排序优化来实现的 
1、对volatile变量执行写操作时，会在写操作后加入一条store屏障指令 
2、对volatile变量执行读操作时，会在读操作前加入一条load屏障指令 
通俗的讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。

# 线程写volatile变量的过程： 
1、改变线程工作内存中volatile变量副本的值 
2、将改变后的副本的值从工作内存刷新到主内存 

# 线程读volatile变量的过程： 
1、从主内存中读取volatile变量的最新值到线程的工作内存中 
2、从工作内存中读取volatile变量的副本

# volatile为什么不能保证volatile变量复合操作的原子性？ 
通俗的讲，volatile不能加锁，对number++;的操作会被多个线程交叉执行，导致出现不同的结果。

# volatile适用场所 
要在多线程中安全的使用volatile变量，必须同时满足： 
1.对变量的写入操作不依赖其当前值 
2.该变量没有包含在具有其他变量的不变式中 

# synchronized和volatile的比较 
1.volatile不需要加锁，比synchronized更轻量级，不会阻塞线程 
2.从内存可见性角度讲，volatile读操作=进入synchronized代码块（加锁），volatile写操作=退出synchronized代码块（解锁） 
3.synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，不能保证原子性